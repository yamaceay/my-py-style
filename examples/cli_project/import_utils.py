#!/usr/bin/env python3
"""
Import Utilities for Package/Script Dual Execution

This module provides utilities for handling both relative imports (when run as module)
and absolute imports (when run as script) seamlessly.

Generated by: Go-ish Python Scaffolder
Author: YamaÃ§ Eren Ay
"""

from __future__ import annotations
import os
import sys
import importlib
from typing import Any, Dict


def smart_import(module_name: str, items: list[str], package_name: str | None = None) -> Dict[str, Any]:
    """
    Import items from a module with automatic fallback between relative and absolute imports.
    
    Args:
        module_name: Name of the module to import from (e.g., 'cli', 'contexts')
        items: List of items to import from the module
        package_name: Optional package name for relative imports (currently unused)
        
    Returns:
        Dictionary mapping item names to imported objects
        
    Usage:
        # Import from cli module
        imports = smart_import('cli', ['build_parser', 'configure_logging'])
        build_parser = imports['build_parser']
        
        # Or unpack directly  
        build_parser, configure_logging = smart_import('cli', ['build_parser', 'configure_logging']).values()
    """
    imported_items = {}
    
    # Try relative imports first (when run as module)
    try:
        # Determine if we're in a package context
        frame = sys._getframe(1)  # noqa: SLF001
        calling_module = frame.f_globals.get('__name__', '')
        
        if '.' in calling_module:  # We're in a package
            # Extract package name
            package_parts = calling_module.split('.')
            if package_parts[-1] == '__main__':
                package_parts = package_parts[:-1]
            
            package = '.'.join(package_parts[:-1]) if len(package_parts) > 1 else package_parts[0]
            relative_module = f".{module_name}"
            
            module = importlib.import_module(relative_module, package=package)
            for item in items:
                imported_items[item] = getattr(module, item)
        else:
            # Direct execution - use absolute imports
            raise ImportError("Not in package context")
            
    except (ImportError, ValueError, AttributeError):
        # Fallback to absolute imports (when run directly)
        # Add current directory to path if not already there
        current_dir = os.path.dirname(os.path.abspath(sys._getframe(1).f_globals['__file__']))  # noqa: SLF001
        if current_dir not in sys.path:
            sys.path.insert(0, current_dir)
            
        try:
            module = importlib.import_module(module_name)
            for item in items:
                imported_items[item] = getattr(module, item)
        except ImportError as e:
            raise ImportError(f"Could not import {items} from {module_name}: {e}") from e
    
    return imported_items


def setup_dual_execution_imports(current_file: str) -> None:
    """
    Setup sys.path for dual execution (both module and script).
    
    Args:
        current_file: __file__ from the calling module
    """
    current_dir = os.path.dirname(os.path.abspath(current_file))
    if current_dir not in sys.path:
        sys.path.insert(0, current_dir)
