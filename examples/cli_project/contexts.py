#!/usr/bin/env python3
"""
Resource Lifecycle Management (Context Managers)

This module provides context managers for automatic resource setup
and cleanup following the RAII (Resource Acquisition Is Initialization) pattern.

Generated by: Go-ish Python Scaffolder
Author: YamaÃ§ Eren Ay
Modification Guidelines:
- Use AbstractContextManager for type safety
- Initialize resources in __enter__, cleanup in __exit__
- Return the managed resource from __enter__
- Handle exceptions appropriately in __exit__
- Log lifecycle events when logging is enabled
"""

from __future__ import annotations
from contextlib import AbstractContextManager
from typing import TYPE_CHECKING, Any
import os
import sys
import logging

if TYPE_CHECKING:
    from .config import AppConfig

# Smart import for core implementations
try:
    from .core import DefaultService, DefaultRepository, DefaultProcessor
except ImportError:
    sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
    from core import DefaultService, DefaultRepository, DefaultProcessor

logger = logging.getLogger(__name__)

class ServiceContext(AbstractContextManager[DefaultService]):
    def __init__(self, config: "AppConfig"):
        self.config = config
        self.service: DefaultService | None = None
        self.repository: DefaultRepository | None = None
        self.processor: DefaultProcessor | None = None
    
    def __enter__(self) -> DefaultService:
        logger.info('initializing_service_context')
        
        self.repository = DefaultRepository()
        self.processor = DefaultProcessor(name=self.config.app_name)
        self.service = DefaultService(
            repository=self.repository,
            processor=self.processor
        )
        
        logger.info('service_context_ready')
        return self.service
    
    def __exit__(self, exc_type, exc_val, exc_tb) -> bool:
        logger.info('releasing_service_resources')
        self.service = None
        self.repository = None
        self.processor = None
        return False

class DataContext(AbstractContextManager["DataContext"]):
    def __init__(self, data_source: str):
        self.data_source = data_source
        self.data: list[Any] | None = None
    
    def __enter__(self) -> "DataContext":
        logger.info('loading_data', extra={'source': self.data_source})
        self.data = []
        logger.info('data_loaded', extra={'count': len(self.data)})
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb) -> bool:
        logger.info('releasing_data')
        self.data = None
        return False
    
    def get_data(self) -> list[Any]:
        if self.data is None:
            raise RuntimeError("Data not initialized - use within context manager")
        return self.data
