#!/usr/bin/env python3
"""
Abstract Base Classes (Interface Definitions)

This module defines the core contracts for the application using ABC patterns.
All interfaces follow Rule #1: minimal, focused responsibilities with clear contracts.

Generated by: Go-ish Python Scaffolder
Author: YamaÃ§ Eren Ay

Architecture Guidelines from README.md:
- Keep interfaces minimal and focused (single responsibility)
- Use @abstractmethod for all required methods
- Avoid implementation details in interfaces
- Define clear contracts that multiple implementations can follow
- Support plug-and-play polymorphism (Rule #2)

Interface Design Principles:
- Methods should accept only essential parameters
- Static dependencies go in implementing class __init__ (Rule #1)
- Dynamic inputs only in method signatures
- Return types should be clear and consistent
"""

from __future__ import annotations
from abc import ABC, abstractmethod
from typing import Any

class Processor(ABC):
    """
    Core data processing contract.
    
    Implementations handle data transformation, analysis, or manipulation.
    Examples: TextProcessor, ImageProcessor, DataNormalizer
    """
    
    @abstractmethod
    def process(self, data: Any) -> Any:
        """
        Process input data and return result.
        
        Args:
            data: Input data to process (dynamic input only)
            
        Returns:
            Processed result
            
        Note: All configuration should be in implementing class __init__
        """
        pass

class Handler(ABC):
    """
    Request/command handling contract.
    
    Implementations handle different types of requests or commands.
    Examples: APIHandler, FileHandler, EventHandler
    """
    
    @abstractmethod
    def handle(self, request: Any) -> Any:
        """
        Handle a request and return response.
        
        Args:
            request: Request to handle (dynamic input only)
            
        Returns:
            Response or result of handling
            
        Note: Handler configuration (routes, auth, etc.) goes in __init__
        """
        pass

class Repository(ABC):
    """
    Data persistence contract.
    
    Implementations provide data storage and retrieval.
    Examples: FileRepository, DatabaseRepository, APIRepository
    """
    
    @abstractmethod
    def save(self, entity: Any) -> bool:
        """
        Persist an entity.
        
        Args:
            entity: Entity to save (dynamic input only)
            
        Returns:
            True if successful, False otherwise
            
        Note: Connection details, credentials go in __init__
        """
        pass
    
    @abstractmethod
    def find(self, identifier: str) -> Any:
        """
        Retrieve an entity by identifier.
        
        Args:
            identifier: Unique identifier (dynamic input only)
            
        Returns:
            Found entity or None if not found
            
        Note: Query configuration goes in implementing class __init__
        """
        pass

class Service(ABC):
    """
    Business logic orchestration contract.
    
    Implementations coordinate between processors, repositories, and handlers.
    Examples: UserService, OrderService, AnalyticsService
    """
    
    @abstractmethod
    def execute(self, params: Any) -> Any:
        """
        Execute business logic with given parameters.
        
        Args:
            params: Execution parameters (dynamic input only)
            
        Returns:
            Result of business logic execution
            
        Note: Service dependencies (processor, repo) injected in __init__
        """
        pass

# Optional: Additional domain-specific interfaces can be added here
# Following the same patterns:

class Validator(ABC):
    """
    Data validation contract.
    
    Implementations provide validation logic for different data types.
    Examples: SchemaValidator, BusinessRuleValidator, FormatValidator
    """
    
    @abstractmethod
    def validate(self, data: Any) -> bool:
        """
        Validate input data.
        
        Args:
            data: Data to validate (dynamic input only)
            
        Returns:
            True if valid, False otherwise
            
        Note: Validation rules configured in implementing class __init__
        """
        pass
    
    @abstractmethod
    def get_errors(self) -> list[str]:
        """
        Get validation error messages from last validation.
        
        Returns:
            List of error messages, empty if no errors
        """
        pass

class Transformer(ABC):
    """
    Data transformation contract.
    
    Implementations convert data between different formats or structures.
    Examples: JsonTransformer, XMLTransformer, FormatConverter
    """
    
    @abstractmethod
    def transform(self, source: Any, target_format: str) -> Any:
        """
        Transform data to target format.
        
        Args:
            source: Source data (dynamic input only)
            target_format: Desired output format (dynamic input only)
            
        Returns:
            Transformed data in target format
            
        Note: Transformation rules configured in implementing class __init__
        """
        pass

# Interface composition example - showing how to combine contracts
class ProcessorService(Service, Processor):
    """
    Example of interface composition for services that also process data.
    
    This demonstrates how interfaces can be combined while maintaining
    clear responsibilities and contracts.
    """
    
    # Inherits both Service.execute() and Processor.process() methods
    # Implementing classes must provide both
    pass
