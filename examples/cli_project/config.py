#!/usr/bin/env python3
"""
Configuration Management

This module follows Rules #3 & #4: One config to rule them all + Passing config downwards.
Single source of truth for all settings with proper canonicalization.

Generated by: Go-ish Python Scaffolder
Author: YamaÃ§ Eren Ay

Modification Guidelines:
- Use @dataclass(frozen=True) for immutable config (Rule #3)
- Build configuration once at application start 
- Pass config down, never re-detect or re-parse (Rule #4)
- Keep configuration flat and explicit
- No global state or hidden defaults
- Use canonicalization functions for computed values

Rules #3 & #4 Examples:
  GOOD: config = create_config(...); processor = Processor(config.name, config.output_dir)
  BAD:  processor.method() -> config = load_config()  # Re-detection forbidden!

  GOOD: Explicit config passing
        service = Service(config.timeout, config.verbose)
  BAD:  Hidden globals
        SERVICE_TIMEOUT = 30  # Global state forbidden!
"""

from __future__ import annotations
from dataclasses import dataclass
from pathlib import Path
from typing import Optional

@dataclass(frozen=True)
class AppConfig:
    """Immutable application configuration - single source of truth (Rule #3)."""
    
    # Core application settings
    app_name: str
    output_dir: Path
    verbose: bool
    
    # Optional configuration  
    config_file: Optional[str] = None
    timeout: int = 30
    max_retries: int = 3
    
    # Computed properties can be methods (since dataclass is frozen)
    @property 
    def log_level(self) -> str:
        """Computed from verbose flag - no re-detection needed."""
        return "DEBUG" if self.verbose else "INFO"
    
    @property
    def processor_name(self) -> str:
        """Computed from app_name - consistent across application."""
        return f"{self.app_name}_processor"

def create_config(
    app_name: str,
    output_dir: str,
    verbose: bool = False,
    config_file: Optional[str] = None,
    timeout: Optional[int] = None,
    max_retries: Optional[int] = None
) -> AppConfig:
    """
    Create and canonicalize configuration - the ONLY place where defaults are applied.
    This function implements Rule #3: single source of truth.
    
    Args:
        app_name: Application name (required)
        output_dir: Output directory path (required)
        verbose: Enable verbose logging (default: False)
        config_file: Optional configuration file path
        timeout: Operation timeout in seconds (default: 30)
        max_retries: Maximum retry attempts (default: 3)
    
    Returns:
        Immutable AppConfig object
        
    Note: This is the ONLY place where defaults are resolved.
    Never re-detect these values in other parts of the application.
    """
    
    # Canonicalize and validate inputs (Rule #3: single source of truth)
    canonical_output_dir = Path(output_dir).resolve()
    canonical_timeout = timeout if timeout is not None else 30
    canonical_max_retries = max_retries if max_retries is not None else 3
    
    # Ensure output directory exists
    canonical_output_dir.mkdir(parents=True, exist_ok=True)
    
    # Validate settings
    if canonical_timeout <= 0:
        raise ValueError(f"Timeout must be positive, got: {canonical_timeout}")
    if canonical_max_retries < 0:
        raise ValueError(f"Max retries must be non-negative, got: {canonical_max_retries}")
    
    return AppConfig(
        app_name=app_name,
        output_dir=canonical_output_dir,
        verbose=verbose,
        config_file=config_file,
        timeout=canonical_timeout,
        max_retries=canonical_max_retries
    )

def extract_config_kwargs(config: AppConfig, *exclude_keys: str) -> dict[str, any]:
    """
    Extract config as kwargs for passing down (Rule #4).
    
    This helper implements Rule #4: passing config downwards.
    Use this to "weaken" config as it goes deeper into the call stack.
    
    Args:
        config: The source configuration
        exclude_keys: Keys to exclude from the result (already extracted)
        
    Returns:
        Dictionary of config values for **kwargs passing
        
    Example:
        config = create_config(...)
        
        # Extract specific values, pass rest as kwargs
        app_name = config.app_name
        output_dir = config.output_dir
        
        # Pass remaining config down
        kwargs = extract_config_kwargs(config, "app_name", "output_dir")
        processor = Processor(app_name, output_dir, **kwargs)
    """
    config_dict = config.__dict__.copy()
    
    # Remove excluded keys (already extracted)
    for key in exclude_keys:
        config_dict.pop(key, None)
        
    return config_dict

# Example of config-driven component setup (follows Rule #4)
def setup_components_from_config(config: AppConfig) -> dict[str, any]:
    """
    Example showing proper config usage following Rule #4.
    
    This demonstrates:
    - No re-detection of config values
    - Explicit extraction of needed parameters  
    - Passing config downwards appropriately
    - No hidden globals or re-parsing
    """
    
    # Extract specific values we need (Rule #4: explicit extraction)
    app_name = config.app_name
    output_dir = config.output_dir
    verbose = config.verbose
    
    # Get remaining config for passing down
    remaining_config = extract_config_kwargs(config, "app_name", "output_dir", "verbose")
    
    # Example component setup with proper config passing
    components = {
        "app_name": app_name,
        "output_dir": output_dir,
        "verbose": verbose,
        "log_level": config.log_level,  # Use computed property
        "processor_name": config.processor_name,  # Use computed property
        "remaining_config": remaining_config
    }
    
    return components

# Anti-pattern examples (DO NOT DO THIS):
# 
# WRONG - Global config (violates Rule #3):
# GLOBAL_CONFIG = {"timeout": 30}  # Hidden global state
# 
# WRONG - Re-detection (violates Rule #4):
# def some_function():
#     config = load_config()  # Re-parsing configuration
#     timeout = os.getenv("TIMEOUT", 30)  # Re-detecting environment
# 
# WRONG - Hidden defaults in deep functions (violates Rule #3):
# def deep_function(data, output_dir="/tmp/default"):  # Should be explicit
