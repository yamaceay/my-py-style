#!/usr/bin/env python3
"""
Application Entry Point and Orchestration

This module wires together all components and provides the main
application logic. Follows Rule #2: Choose concrete class once (early selection),
then call common method. No if/elif/else ladders.

Generated by: Go-ish Python Scaffolder
Author: Yamaç Eren Ay

Modification Guidelines:
- Keep main() focused on orchestration
- Use early selection for polymorphism (Rule #2) 
- Use context managers for resource management (Rule #5)
- Handle errors at the application boundary
- Configure logging before any business logic
- No runtime branching - choose concrete class once

Rule #2 Examples:
  GOOD: Choose once, execute with common interface
        command_handler = RunCommandHandler() if args.command == "run" else ProcessCommandHandler()
        return command_handler.execute(config)
  
  BAD:  Runtime branching everywhere
        if args.command == "run": return run_logic(config)
        elif args.command == "process": return process_logic(config)
"""

from __future__ import annotations
from typing import TYPE_CHECKING, Protocol
import sys
import os

if TYPE_CHECKING:
    from .config import AppConfig

# Import using the smart import utility
try:
    from .import_utils import smart_import
except ImportError:
    sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
    from import_utils import smart_import

# Use smart import for all module dependencies
context_imports = smart_import('contexts', ['ServiceContext'])
cli_imports = smart_import('cli', ['build_parser', 'configure_logging', 'validate_args', 'parse_args_to_config'])

# Extract imports for clean usage
ServiceContext = context_imports['ServiceContext']
build_parser = cli_imports['build_parser']
configure_logging = cli_imports['configure_logging']
validate_args = cli_imports['validate_args']
parse_args_to_config = cli_imports['parse_args_to_config']

# Command Handler Protocol (Rule #1: Contract as ABC)
class CommandHandler(Protocol):
    def execute(self, config: "AppConfig") -> int:
        """Execute command with given configuration."""
        ...

# Concrete Command Handlers (Rule #1: Small classes, static deps in __init__)
class RunCommandHandler:
    """Handler for run command - no static dependencies needed."""
    
    def execute(self, config: "AppConfig") -> int:
        """Execute the main application logic."""
        print(f"Running {config.app_name}...")
        
        with ServiceContext(config) as service:
            # Example data processing
            test_data = {"message": "Hello from CLI!", "timestamp": "2024-01-01"}
            result = service.execute(test_data)
            
            if config.verbose:
                print(f"Processing result: {result}")
            
            print("✅ Run completed successfully!")
            return 0

class ProcessCommandHandler:
    """Handler for process command - no static dependencies needed."""
    
    def execute(self, config: "AppConfig") -> int:
        """Process data with additional context."""
        print(f"Processing data for {config.app_name}...")
        
        with ServiceContext(config) as service:
            # Simulate data processing workflow
            sample_data = [
                {"id": 1, "value": "first"},
                {"id": 2, "value": "second"}, 
                {"id": 3, "value": "third"}
            ]
            
            results = []
            for item in sample_data:
                result = service.execute(item)
                results.append(result)
                
                if config.verbose:
                    print(f"Processed item {item['id']}: {result['processed']}")
            
            print(f"✅ Processed {len(results)} items successfully!")
            return 0

class StatusCommandHandler:
    """Handler for status command - no static dependencies needed."""
    
    def execute(self, config: "AppConfig") -> int:
        """Show application status and configuration."""
        print(f"Status for {config.app_name}")
        print(f"Output directory: {config.output_dir}")
        print(f"Verbose mode: {config.verbose}")
        print(f"Config file: {config.config_file or 'None'}")
        print("✅ Application is ready!")
        return 0

def main() -> int:
    """Main application entry point - demonstrates Rule #2 early selection."""
    try:
        # Parse command line arguments
        parser = build_parser()
        args = parser.parse_args()
        
        # Validate arguments
        validate_args(args)
        
        # Configure logging
        configure_logging(args.verbose)
        
        # Create configuration
        config = parse_args_to_config(args)
        
        if args.command == "run":
            command_handler: CommandHandler = RunCommandHandler()
        elif args.command == "process":
            command_handler = ProcessCommandHandler()
        elif args.command == "status":
            command_handler = StatusCommandHandler()
        else:
            print(f"Unknown command: {args.command}", file=sys.stderr)
            return 1
        
        # Now execute with common interface - no more branching!
        return command_handler.execute(config)
            
    except (ValueError, RuntimeError) as e:
        print(f"Error: {e}", file=sys.stderr)
        return 1
    except KeyboardInterrupt:
        print("\nOperation cancelled by user.", file=sys.stderr)
        return 130

if __name__ == "__main__":
    sys.exit(main())
