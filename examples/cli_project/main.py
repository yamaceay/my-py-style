#!/usr/bin/env python3
"""
Application Entry Point and Orchestration

This module wires together all components and provides the main
application logic. Follows dependency injection patterns.

Generated by: Go-ish Python Scaffolder
Author: Yamaç Eren Ay
Modification Guidelines:
- Keep main() focused on orchestration
- Use context managers for resource management
- Handle errors at the application boundary
- Configure logging before any business logic
"""

from __future__ import annotations
from typing import TYPE_CHECKING
import sys
import os

if TYPE_CHECKING:
    from .config import AppConfig

# Import using the smart import utility
try:
    from .import_utils import smart_import
except ImportError:
    sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
    from import_utils import smart_import

# Use smart import for all module dependencies
context_imports = smart_import('contexts', ['ServiceContext'])
cli_imports = smart_import('cli', ['build_parser', 'configure_logging', 'validate_args', 'parse_args_to_config'])

# Extract imports for clean usage
ServiceContext = context_imports['ServiceContext']
build_parser = cli_imports['build_parser']
configure_logging = cli_imports['configure_logging']
validate_args = cli_imports['validate_args']
parse_args_to_config = cli_imports['parse_args_to_config']

def main() -> int:
    """Main application entry point."""
    try:
        # Parse command line arguments
        parser = build_parser()
        args = parser.parse_args()
        
        # Validate arguments
        validate_args(args)
        
        # Configure logging
        configure_logging(args.verbose)
        
        # Create configuration
        config = parse_args_to_config(args)
        
        # Execute command
        if args.command == "run":
            return run_command(config)
        elif args.command == "process":
            return process_command(config)
        elif args.command == "status":
            return status_command(config)
        else:
            print(f"Unknown command: {args.command}", file=sys.stderr)
            return 1
            
    except (ValueError, RuntimeError) as e:
        print(f"Error: {e}", file=sys.stderr)
        return 1
    except KeyboardInterrupt:
        print("\nOperation cancelled by user.", file=sys.stderr)
        return 130

def run_command(config: "AppConfig") -> int:
    """Execute the main application logic."""
    print(f"Running {config.app_name}...")
    
    with ServiceContext(config) as service:
        # Example data processing
        test_data = {"message": "Hello from CLI!", "timestamp": "2024-01-01"}
        result = service.execute(test_data)
        
        if config.verbose:
            print(f"Processing result: {result}")
        
        print("✅ Run completed successfully!")
        return 0

def process_command(config: "AppConfig") -> int:
    """Process data with additional context."""
    print(f"Processing data for {config.app_name}...")
    
    with ServiceContext(config) as service:
        # Simulate data processing workflow
        sample_data = [
            {"id": 1, "value": "first"},
            {"id": 2, "value": "second"},
            {"id": 3, "value": "third"}
        ]
        
        results = []
        for item in sample_data:
            result = service.execute(item)
            results.append(result)
            
            if config.verbose:
                print(f"Processed item {item['id']}: {result['processed']}")
        
        print(f"✅ Processed {len(results)} items successfully!")
        return 0

def status_command(config: "AppConfig") -> int:
    """Show application status and configuration."""
    print(f"Status for {config.app_name}")
    print(f"Output directory: {config.output_dir}")
    print(f"Verbose mode: {config.verbose}")
    print(f"Config file: {config.config_file or 'None'}")
    print("✅ Application is ready!")
    return 0

if __name__ == "__main__":
    sys.exit(main())
