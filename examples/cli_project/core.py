#!/usr/bin/env python3
"""
Core Business Logic Implementations

This module contains concrete implementations of all interfaces defined
in interfaces.py. Follows Rule #1: static dependencies in constructor,
methods accept only dynamic inputs.

Generated by: Go-ish Python Scaffolder
Author: YamaÃ§ Eren Ay

Modification Guidelines:
- Use @dataclass(frozen=True) for static dependencies (passed in, never change)
- Use regular __init__ for dynamic initialization or computed dependencies  
- Static deps go in constructor: tokenizer, labels, device, paths, config
- Methods only accept dynamic inputs: data to process, requests to handle
- Keep methods focused on single responsibilities
- Log with structured context when enabled

Rule #1 Examples:
  GOOD: processor = DefaultProcessor(name="task_processor", config=app_config)
        result = processor.process(data)  # Only dynamic input
  
  BAD:  result = processor.process(data, name="task_processor")  # Static in method
"""

from __future__ import annotations
from dataclasses import dataclass
from typing import TYPE_CHECKING, Any
import os
import sys
import logging


if TYPE_CHECKING:
    from .config import AppConfig

# Smart import for interfaces
try:
    from .interfaces import Processor, Handler, Repository, Service
except ImportError:
    sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
    from interfaces import Processor, Handler, Repository, Service

logger = logging.getLogger(__name__)

@dataclass(frozen=True)
class DefaultProcessor(Processor):
    """Example of @dataclass(frozen=True) with static dependencies."""
    name: str                    # Static dependency - passed once, never changes
    processing_mode: str = "default"  # Static configuration
    
    def process(self, data: Any) -> Any:
        """Method accepts only dynamic input - data to process."""
        logger.info('processing_data', extra={'processor': self.name, 'mode': self.processing_mode})
        return {
            "processed": True, 
            "data": data, 
            "processor": self.name,
            "mode": self.processing_mode
        }

@dataclass(frozen=True)
class DefaultHandler(Handler):
    """Example of dependency injection - service is static dependency."""
    service: Service            # Static dependency - injected once
    handler_name: str = "default"
    
    def handle(self, request: Any) -> Any:
        """Method accepts only dynamic input - request to handle."""
        logger.info('handling_request', extra={'handler': self.handler_name, 'request_type': type(request).__name__})
        return self.service.execute(request)

class DefaultRepository(Repository):
    """Example of regular __init__ for dynamic initialization."""
    
    def __init__(self, storage_config: str = "memory"):
        """Dynamic initialization - can compute storage based on config."""
        self.storage_config = storage_config
        self._storage: dict[str, Any] = {}
        
        # Example of computed initialization
        if storage_config == "persistent":
            # Would initialize file/db storage here
            pass
    
    def save(self, entity: Any) -> bool:
        """Method accepts only dynamic input - entity to save."""
        entity_id = getattr(entity, "id", str(hash(str(entity))))
        self._storage[entity_id] = entity
        logger.debug('entity_saved', extra={'entity_id': entity_id, 'storage': self.storage_config})
        return True
    
    def find(self, identifier: str) -> Any:
        """Method accepts only dynamic input - identifier to find."""
        result = self._storage.get(identifier)
        logger.debug('entity_found', extra={'entity_id': identifier, 'found': result is not None})
        return result

@dataclass(frozen=True) 
class DefaultService(Service):
    """Example of composition with static dependency injection."""
    repository: Repository      # Static dependency - injected once
    processor: Processor       # Static dependency - injected once
    service_name: str = "default"
    
    def execute(self, params: Any) -> Any:
        """Method accepts only dynamic input - params to execute on."""
        logger.info('service_execution_start', extra={'service': self.service_name, 'params_type': type(params).__name__})
        
        # Pure business logic - no branching, no re-configuration
        processed = self.processor.process(params)
        self.repository.save(processed)
        
        logger.info('service_execution_complete', extra={'service': self.service_name})
        return processed

# Example of config-driven initialization (follows Rule #3 & #4)
class ConfigDrivenProcessor(Processor):
    """Example using config for dynamic initialization."""
    
    def __init__(self, config: "AppConfig"):
        """Takes config for computed dependencies."""
        self.app_name = config.app_name           # Extract what we need
        self.output_dir = config.output_dir       # No hidden globals
        self.verbose = config.verbose             # Single source of truth
        
        # Computed initialization based on config
        self.processor_id = f"{self.app_name}_processor"
        
        # Set up output directory if needed
        self.output_dir.mkdir(parents=True, exist_ok=True)
    
    def process(self, data: Any) -> Any:
        """Only dynamic input - no config re-detection."""
        if self.verbose:
            logger.debug('config_driven_processing', extra={'processor_id': self.processor_id})
        
        return {
            "processed": True,
            "data": data,
            "processor_id": self.processor_id,
            "output_path": str(self.output_dir)
        }
